<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2023/01/18/ri-chang-bi-ji/"/>
      <url>/2023/01/18/ri-chang-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>pytest的参数化可以传入一个ids进行区分<br>@pytest.mark.parametrize(‘in_data’, eval(re_data), ids&#x3D;[i[‘detail’] for i in TestData])</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客搭建</title>
      <link href="/2023/01/16/hexo-bo-ke-da-jian/"/>
      <url>/2023/01/16/hexo-bo-ke-da-jian/</url>
      
        <content type="html"><![CDATA[<p>参照<a href="https://blog.csdn.net/sinat_37781304/article/details/82729029">hexo史上最全搭建教程</a>搭建了hexo个人网站。</p><h1 id="hexo简介"><a href="#hexo简介" class="headerlink" title="hexo简介"></a>hexo简介</h1><p>Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。大家可以进入<a href="https://hexo.io/zh-cn/">hexo官网</a>进行详细查看，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。</p><h1 id="hexo搭建步骤"><a href="#hexo搭建步骤" class="headerlink" title="hexo搭建步骤"></a>hexo搭建步骤</h1><ol><li><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2></li><li><h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2></li><li><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2></li><li><h2 id="GitHub创建个人仓库"><a href="#GitHub创建个人仓库" class="headerlink" title="GitHub创建个人仓库"></a>GitHub创建个人仓库</h2></li><li><h2 id="生成SSH添加到GitHub"><a href="#生成SSH添加到GitHub" class="headerlink" title="生成SSH添加到GitHub"></a>生成SSH添加到GitHub</h2></li><li><h2 id="将hexo部署到GitHub"><a href="#将hexo部署到GitHub" class="headerlink" title="将hexo部署到GitHub"></a>将hexo部署到GitHub</h2></li><li><h2 id="设置个人域名"><a href="#设置个人域名" class="headerlink" title="设置个人域名"></a>设置个人域名</h2></li><li><h2 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h2></li><li><h2 id="安装Git-1"><a href="#安装Git-1" class="headerlink" title="安装Git"></a>安装Git</h2></li><li><h2 id="安装Node-js-1"><a href="#安装Node-js-1" class="headerlink" title="安装Node.js"></a>安装Node.js</h2></li><li><h2 id="安装Hexo-1"><a href="#安装Hexo-1" class="headerlink" title="安装Hexo"></a>安装Hexo</h2></li><li><h2 id="GitHub创建个人仓库-1"><a href="#GitHub创建个人仓库-1" class="headerlink" title="GitHub创建个人仓库"></a>GitHub创建个人仓库</h2></li><li><h2 id="生成SSH添加到GitHub-1"><a href="#生成SSH添加到GitHub-1" class="headerlink" title="生成SSH添加到GitHub"></a>生成SSH添加到GitHub</h2></li><li><h2 id="将hexo部署到GitHub-1"><a href="#将hexo部署到GitHub-1" class="headerlink" title="将hexo部署到GitHub"></a>将hexo部署到GitHub</h2></li><li><h2 id="设置个人域名-1"><a href="#设置个人域名-1" class="headerlink" title="设置个人域名"></a>设置个人域名</h2></li><li><h2 id="发布文章-1"><a href="#发布文章-1" class="headerlink" title="发布文章"></a>发布文章</h2></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux常用命令</title>
      <link href="/2022/12/02/linux-chang-yong-ming-ling/"/>
      <url>/2022/12/02/linux-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h3><pre class="line-numbers language-none"><code class="language-none">catchmoddiffcutmvteecpwhichwhereisawkscpsedtrsortheadtaillessmoreunziptarviwclnuniqnlxargs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="具体案例"><a href="#具体案例" class="headerlink" title="具体案例"></a>具体案例</h3><h4 id="复制文件夹"><a href="#复制文件夹" class="headerlink" title="复制文件夹"></a>复制文件夹</h4><p>cp -r 文件夹</p><h4 id="统计文件有多少行"><a href="#统计文件有多少行" class="headerlink" title="统计文件有多少行"></a>统计文件有多少行</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wc</span> testfile           <span class="token comment"># testfile文件的统计信息  </span><span class="token number">3</span> <span class="token number">92</span> <span class="token number">598</span> testfile       <span class="token comment"># testfile文件的行数为3、单词数92、字节数598</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>-c或–bytes或–chars 只显示Bytes数。</li><li>-l或–lines 显示行数。</li><li>-w或–words 只显示字数。</li></ul><h4 id="建立软链接-快捷方式-，以及硬链接的命令。"><a href="#建立软链接-快捷方式-，以及硬链接的命令。" class="headerlink" title="建立软链接(快捷方式)，以及硬链接的命令。"></a><strong>建立软链接(快捷方式)，以及硬链接的命令。</strong></h4><p> 软链接： ln -s slink source<br> 硬链接： ln link source </p><h4 id="which、whereis、find、locate的区别"><a href="#which、whereis、find、locate的区别" class="headerlink" title="which、whereis、find、locate的区别"></a>which、whereis、find、locate的区别</h4><h4 id="sort命令"><a href="#sort命令" class="headerlink" title="sort命令"></a>sort命令</h4><ul><li>-n 依照数值的大小排序。</li><li>-r 以相反的顺序来排序</li><li>[-k field1[,field2]] 按指定的列进行排序。</li></ul><h4 id="uniq命令用法"><a href="#uniq命令用法" class="headerlink" title="uniq命令用法"></a>uniq命令用法</h4><p>用于检查及删除文本文件中重复出现的行列，一般与 sort 命令结合使用</p><ul><li>-c或–count 在每列旁边显示该行重复出现的次数。</li><li>-d或–repeated 仅显示重复出现的行列。</li></ul><p>当文件中重复行不是连续的，uniq是不起作用的，所以要结合sort使用</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 统计文件中不重复的行</span><span class="token function">sort</span> test.txt <span class="token operator">|</span> <span class="token function">uniq</span><span class="token comment"># 统计各行在文件中出现的次数</span><span class="token function">sort</span> testfile1 <span class="token operator">|</span> <span class="token function">uniq</span> -c<span class="token comment"># 在文件中找出重复的行</span><span class="token function">sort</span> testfile1 <span class="token operator">|</span> <span class="token function">uniq</span> -d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h4><p>xargs 用作替换工具，读取输入数据重新格式化后输出。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 多行转换为单行输出# </span><span class="token function">cat</span> test.txt <span class="token operator">|</span> <span class="token function">xargs</span><span class="token function">cat</span> test.txt <span class="token operator">|</span> <span class="token function">xargs</span><span class="token comment"># 每行三个数据进行展示</span><span class="token function">cat</span> test.txt <span class="token operator">|</span> <span class="token function">xargs</span> -n3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><h3 id="常见命令-1"><a href="#常见命令-1" class="headerlink" title="常见命令"></a>常见命令</h3><pre class="line-numbers language-none"><code class="language-none">dfducdmkdirlsrmdirpwd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="具体案例-1"><a href="#具体案例-1" class="headerlink" title="具体案例"></a>具体案例</h3><h4 id="du-和-df-的定义，以及区别？"><a href="#du-和-df-的定义，以及区别？" class="headerlink" title="du 和 df 的定义，以及区别？"></a><strong>du 和 df 的定义，以及区别？</strong></h4><p> <strong>答案：</strong> </p><p> du 显示目录或文件的大小 </p><p> df 显示每个&lt;文件&gt;所在的文件系统的信息，默认是显示所有文件系统。<br> （文件系统分配其中的一些磁盘块用来记录它自身的一些数据，如 i 节点，磁盘分布图，间接块，超级块等。这些数据对大多数用户级的程序来说是不可见的，通常称为 Meta Data。） du 命令是用户级的程序，它不考虑 Meta Data，而 df 命令则查看文件系统的磁盘分配图并考虑 Meta Data。<br> df 命令获得真正的文件系统数据，而 du 命令只查看文件系统的部分情况。 </p><pre class="line-numbers language-none"><code class="language-none">df -h查看当前目录df -h &#x2F;usr&#x2F;  查看指定目录du --max-depth&#x3D;1 -h 查看当前目录每个文件夹的情况du --max-depth&#x3D;1 -h  &#x2F;usr&#x2F; 指定目录du -sh &#x2F;usr&#x2F; 计算文件夹大小<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="创建多级目录"><a href="#创建多级目录" class="headerlink" title="创建多级目录"></a>创建多级目录</h4><p>mkdir -p</p><h2 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h2><h3 id="常见命令-2"><a href="#常见命令-2" class="headerlink" title="常见命令"></a>常见命令</h3><pre class="line-numbers language-none"><code class="language-none">ncifconfignetstat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="具体案例-2"><a href="#具体案例-2" class="headerlink" title="具体案例"></a>具体案例</h3><h4 id="netstat命令参数"><a href="#netstat命令参数" class="headerlink" title="netstat命令参数"></a>netstat命令参数</h4><p>列出所有端口 netstat -a<br>列出所有 tcp 端口 netstat -at<br>列出所有 udp 端口 netstat -au</p><h2 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h2><h3 id="常见命令-3"><a href="#常见命令-3" class="headerlink" title="常见命令"></a>常见命令</h3><pre class="line-numbers language-none"><code class="language-none">datekillpstoppstreetreeshutdownunamewhofreecrontabyumjobhistory<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="具体案例-3"><a href="#具体案例-3" class="headerlink" title="具体案例"></a>具体案例</h3><h4 id="查看linux系统版本和内核版本"><a href="#查看linux系统版本和内核版本" class="headerlink" title="查看linux系统版本和内核版本"></a>查看linux系统版本和内核版本</h4><p><strong>查看内核版本</strong></p><p>cat &#x2F;proc&#x2F;version</p><p>uname -a</p><p><strong>查看Linux系统版本的命令</strong></p><p>lsb_release -a  有的版本支持</p><p>cat &#x2F;etc&#x2F;redhat-release 适合redhat系的linux，如centos</p><p>cat &#x2F;etc&#x2F;issue  适合所有版本</p><h4 id="ps-aux命令中常见状态"><a href="#ps-aux命令中常见状态" class="headerlink" title="ps aux命令中常见状态"></a>ps aux命令中常见状态</h4><p><img src="C:\Users\Administrator\blog\newblog\source\picture\image-20221119164738929.png" alt="image-20221119164738929"></p><h4 id="free命令"><a href="#free命令" class="headerlink" title="free命令"></a>free命令</h4><p>​用于显示内存状态。</p><p>​会显示内存的使用情况，包括实体内存，虚拟的交换文件内存，共享内存区段，以及系统核心使用的缓冲区等。</p><h4 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h4><p> top命令用于实时显示 process 的动态。</p><p><a href="http://c.biancheng.net/view/1065.html">Linux top命令详解：持续监听进程运行状态 (biancheng.net)</a></p><p>top -b -n 1 &gt; &#x2F;root&#x2F;top.log#让top命令只执行一次，然后把执行结果保存到top.log文件中，这样就能看到所有的进程了</p><ul><li>-b：使用批处理模式输出。一般和”-n”选项合用，用于把 top 命令重定向到文件中；</li><li>-n 次数：指定 top 命令执行的次数。一般和”-“选项合用；</li><li>-p 进程PID：仅查看指定 ID 的进程；</li></ul><p>top命令可以按shift+f设置排序规则和展示内容</p><h4 id="查看某个进程下线程信息"><a href="#查看某个进程下线程信息" class="headerlink" title="查看某个进程下线程信息"></a>查看某个进程下线程信息</h4><p>top -H -p <PID></p><p>ps -T -p <PID></p><p>另外pstree -p <PID>可以查看这些进程的父子关系</p><h4 id="ps-ef和ps-aux的区别"><a href="#ps-ef和ps-aux的区别" class="headerlink" title="ps -ef和ps aux的区别"></a>ps -ef和ps aux的区别</h4><p>ps -ef包含进程和父进程</p><p>ps aux包含内存CPU的占用情况</p><h4 id="查看后台任务"><a href="#查看后台任务" class="headerlink" title="查看后台任务?"></a>查看后台任务?</h4><p>job -l</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>grep、sed、awk三剑客</title>
      <link href="/2022/12/01/grep-sed-awk-san-jian-ke/"/>
      <url>/2022/12/01/grep-sed-awk-san-jian-ke/</url>
      
        <content type="html"><![CDATA[<h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>文本搜索工具，支持使用正则表达式搜索文本，全称为Global Regular Expression Print。</p><h3 id="参数选项"><a href="#参数选项" class="headerlink" title="参数选项"></a>参数选项</h3><p><strong>[options]主要参数：</strong></p><blockquote><p><strong>-c：只输出匹配行的计数。 -i：不区分大 小写(只适用于单字符)。</strong><br>-h：查询多文件时不显示文件名。<br>-l：查询多文件时只输出包含匹配字符的文件名。<br><strong>-n：显示匹配行及 行号。</strong><br>-s：不显示不存在或无匹配文本的错误信息。<br><strong>-v：排除，不显示过滤的字符串的行；显示不包含匹配文本的所有行</strong><br>-e : 指定字符串做为查找文件内容的样式，可以指定多个<br><strong>-E ：将样式为延伸的正则表达式来使用。</strong><br><strong>-o ：输出精确匹配的字符而不是默认的整行</strong><br>-f ：指定规则文件，其内容含有一个或多个规则样式<br>        让grep查找符合规则条件的文件内容，格式为每行一个规则样式</p></blockquote><p><strong>Context control：</strong></p><blockquote><p>-B 除了显示匹配的一行之外，并显示该行之前的num行<br>-A 除了显示匹配的一行之外，并显示该行之后的num行<br>-C 除了显示匹配的一行之外，并显示该行之前后各num行</p></blockquote><p><strong>pattern正则表达式主要参数：</strong></p><blockquote><p>\：忽略正则表达式中特殊字符的原有含义。<br>.：所有的单个字符。<br>*：有字符，长度可以为0。^：匹配正则表达式的开始行。<br>$: 匹配正则表达式的结束行。<br>&lt;：从匹配正则表达 式的行开始。<br>&gt;：到匹配正则表达式的行结束。<br>[ ]：单个字符，如 [Gg]rep 匹配Grep和grep。<br>[ - ]：范围，如[A-Z]，即A、B、C一直到Z都符合要求。<br>[^]：匹配一个不在指定范围内的字符<br>        如：’[^A-FH-Z]rep’匹配不包含A-F和H-Z的一个字母开头，紧跟rep的行<br>x{m}：重复字符x，m次，如：’0{5}‘匹配包含5个0的行<br>x{m,}：重复字符x,至少m次，如：’0{5,}‘匹配至少有5个0的行<br>x{m,n}：重复字符x，至少m次，不多于n次，如：’0{5,10}‘匹配5 – 10个0的行</p></blockquote><h3 id="常用示例"><a href="#常用示例" class="headerlink" title="常用示例"></a>常用示例</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 查找指定进程个数</span><span class="token function">ps</span> -ef <span class="token operator">|</span><span class="token function">grep</span> -c sshd<span class="token comment"># 查找test.txt中符合文件test2.txt的规则的内容，test2.txt有多行</span><span class="token function">cat</span> test.txt <span class="token operator">|</span> <span class="token function">grep</span> -f test2.txt<span class="token comment"># 查找test.txt中符合文件test2.txt的规则的内容，并显示行号</span><span class="token function">cat</span> test.txt <span class="token operator">|</span> <span class="token function">grep</span> -nf test2.txt<span class="token comment"># 从多个文件中查找关键词</span><span class="token function">grep</span> <span class="token string">'linux'</span> test.txt test2.txt<span class="token comment"># 查找以w开头的行内容</span><span class="token function">cat</span> test.txt <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">'^w'</span><span class="token comment"># 查找以w结尾的行内容</span><span class="token function">cat</span> test.txt <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">'w$'</span><span class="token comment"># 查找非u开头的行内容</span><span class="token function">cat</span> test.txt <span class="token operator">|</span> <span class="token function">grep</span> ^<span class="token punctuation">[</span>^u<span class="token punctuation">]</span><span class="token comment"># 查找有有连续两个uu以上的行内容</span><span class="token function">cat</span> test.txt <span class="token operator">|</span><span class="token function">grep</span> -E <span class="token string">'u&#123;2,&#125;'</span> <span class="token function">grep</span> -v <span class="token string">'^$'</span> test.txt<span class="token function">cat</span> test.txt <span class="token operator">|</span><span class="token function">grep</span> <span class="token string">'u\&#123;2,\&#125;'</span><span class="token comment"># 查找包含ab或者cd的行内容</span><span class="token function">cat</span> test.txt <span class="token operator">|</span><span class="token function">grep</span> -E <span class="token string">'ab|cd'</span><span class="token function">cat</span> test.txt <span class="token operator">|</span><span class="token function">grep</span> <span class="token string">'ab\|cd'</span><span class="token comment"># 查找当前目录以txt结尾的文件中所有包含每个字符串至少有7个连续小写字符的字符串的行</span><span class="token function">grep</span> -E <span class="token string">'[a-z]&#123;7,&#125;'</span> *.txt<span class="token comment"># 查找包含ab的行内容并显示接下来的10行</span><span class="token function">grep</span> <span class="token string">'ab'</span> -A <span class="token number">10</span> test.txt<span class="token comment"># 过滤空行内容并输出</span> <span class="token function">grep</span> -v <span class="token string">'^$'</span> test.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><h3 id="参数选项-1"><a href="#参数选项-1" class="headerlink" title="参数选项"></a>参数选项</h3><p><strong>参数说明</strong>：</p><blockquote><p>-e 以选项中指定的script来处理输入的文本文件。</p><p>-f以选项中指定的script文件来处理输入的文本文件。</p><p>-h或–help 显示帮助。</p><p>-n或–quiet或–silent 仅显示script处理后的结果。</p><p>-V或–version 显示版本信息。</p></blockquote><p><strong>动作说明</strong>：</p><blockquote><p>a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～</p><p>c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！</p><p>d ：删除，因为是删除啊，所以 d 后面通常不接任何东东；</p><p>i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；</p><p><strong>p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～</strong></p><p>s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正则表达式！例如 1,20s&#x2F;old&#x2F;new&#x2F;g 就是啦！</p></blockquote><h3 id="常用示例-1"><a href="#常用示例-1" class="headerlink" title="常用示例"></a>常用示例</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 在test文件的第四行后添加一行，并将结果输出到标准输出</span><span class="token function">sed</span> <span class="token string">'4a newline'</span> test.txt<span class="token comment"># 将test文件的内容列出并列出行号，同事将2-5行删除</span><span class="token function">nl</span> test.txt <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'2,5d'</span><span class="token comment"># 在第二行前插入</span><span class="token function">nl</span> test.txt <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'2i newline'</span><span class="token comment"># 在第二行后加入两行字(使用反斜杠)</span><span class="token function">nl</span> test.txt <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">'2a newline\newline_2'</span><span class="token comment"># 搜索test中有关键字oo的行</span><span class="token function">nl</span> test.txt <span class="token operator">|</span> <span class="token function">sed</span> -n <span class="token string">'/oo/p'</span><span class="token comment"># 将test.txt文件中每行第一次出现的oo用kk替换</span><span class="token function">sed</span> -e <span class="token string">'s/oo/kk/'</span> test.txt<span class="token comment"># 将test.txt所有的oo用kk替换，并更新文件</span><span class="token function">sed</span> -i <span class="token string">'s/oo/kk/g'</span> test.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><h3 id="参数选项-2"><a href="#参数选项-2" class="headerlink" title="参数选项"></a>参数选项</h3><ul><li>-F fs or –field-separator fs<br>指定输入文件折分隔符，fs是一个字符串或者是一个正则表达式，如-F:。</li></ul><h3 id="常用示例-2"><a href="#常用示例-2" class="headerlink" title="常用示例"></a>常用示例</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 每行按空格或TAB分割，输出文本中的1、4项</span><span class="token function">awk</span> <span class="token string">'&#123;print $1,$4&#125;'</span> log.txt<span class="token comment"># 使用","分割</span><span class="token function">awk</span> -F, <span class="token string">'&#123;print $1,$2&#125;'</span>   log.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 三剑客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git笔记</title>
      <link href="/2022/11/26/git-bi-ji/"/>
      <url>/2022/11/26/git-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="git核心"><a href="#git核心" class="headerlink" title="git核心"></a>git核心</h2><p>![Screenshot_20220416_171404_tv.danmaku.bili](D:\Huawei Share\Huawei Share\Screenshot_20220416_171404_tv.danmaku.bili.jpg)</p><h2 id="git登录"><a href="#git登录" class="headerlink" title="git登录"></a>git登录</h2><p>查看当前登录账号：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">git</span> config user.name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看当前登录邮箱</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">git</span> config user.email<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改用户名和邮箱：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">git</span> config --global user.name <span class="token string">"Your_username"</span><span class="token function">git</span> config --global user.email <span class="token string">"Your_email"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>初始化一个Git仓库，使用<code>git init</code>命令。</p><p>添加文件到Git仓库，分两步：</p><ol><li>使用命令<code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件；</li><li>使用命令<code>git commit -m &lt;message&gt;</code>，完成。</li></ol><ul><li>要随时掌握工作区的状态，使用<code>git status</code>命令。</li><li>如果<code>git status</code>告诉你有文件被修改过，用<code>git diff</code>可以查看修改内容。</li></ul><h2 id="版本切换"><a href="#版本切换" class="headerlink" title="版本切换"></a>版本切换</h2><ul><li><code>HEAD</code>指向的版本就是当前版本，HEAD^表示上一个版本，HEAD^^表示上上个版本，HEAD~100表示往上100个版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>，commit_id版本号不需要写全，只需要写前几个。</li><li>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</li><li>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</li></ul><p>git把本地仓库推到github上</p><pre class="line-numbers language-none"><code class="language-none">git remote add origin https:&#x2F;&#x2F;github.com&#x2F;Sheep1433&#x2F;learngit.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="C:\Users\Administrator\blog\newblog\source\picture\image-20211223210005615.png" alt="image-20211223210005615"></p><pre class="line-numbers language-none"><code class="language-none">git checkout -- file 撤销对file的修改<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在本机上创建ssh key，然后在主目录的.ssh文件夹中将公钥复制到github或者gitee中即可。</p><pre class="line-numbers language-none"><code class="language-none">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后在本地仓库目录下运行以下命令，将本地仓库和远程库关联</p><pre class="line-numbers language-none"><code class="language-none">git remote add origin git@github.com:Sheep1433&#x2F;learngit.git或者git remote add origin https:&#x2F;&#x2F;github.com&#x2F;Sheep1433&#x2F;learngit.git# git支持多种协议，如ssh和https,默认的git:&#x2F;&#x2F;使用的是ssh协议，速度快<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>将本地仓库内容推送到远程库</p><pre class="line-numbers language-none"><code class="language-none">git push -u origin master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第一次推送master分支时，加上-u参数，会同时将本地master和远程库的master关联起来，以后的推送或拉取可以简化命令</p><p>如</p><pre class="line-numbers language-none"><code class="language-none">git push 或者 git push origin master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>解除本地仓库和远程库的链接</strong></p><p>查看远程库信息</p><pre class="line-numbers language-none"><code class="language-none">git remote -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后删除</p><pre class="line-numbers language-none"><code class="language-none">git remote rm origin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>创建dev分支并且切换</p><pre class="line-numbers language-none"><code class="language-none">git checkout -b dev等同于 git branch dev 加上git checkout dev也等同于git switch -c dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用git branch查看分支</p><p>在dev分支中完成代码工作后，并使用git add和git commit 提交后，切换至master分支，是无法看到dev分支的工作的，通过在master分支中使用git merge dev命令合并分支。</p><pre class="line-numbers language-none"><code class="language-none">删除分支git branch -d dev创建分支并切换git checkout -b dev查看分支git branch查看日志git log合并分支git merge dev禁用Fast-Forward模式进行合并分支git merge --no-ff -m &quot;merge with no-ff&quot; devgit stash命令的场景假设：保留工作现场git stash切换master分支  git checkout master创建新分支git checkout -b issue001git add 和git commit -m提交修复切回master分支 git switch master将issue分支合并入master分支git merge --no-ff -m &quot;merge with no-ff&quot; issue001切回dev分支git switch dev查看工作现场git stash list恢复现场并删除git stash apply和git stash drop等同于git stash pop恢复指定的stashgit stash apply stash@&#123;0&#125;删除还没有合并的分支git branch -D feature-vulcan从本地推送分支git push origin branch-name如果推送失败，先用git pull抓取在本地创建和远程分支对应的分支git checkout -b branch-name origin&#x2F;branch-name建立本地分支和远程分支的管理git branch --set-upstream-to branch-name rigin&#x2F;branch-name查看日志git log查看日志git log --pretty&#x3D;oneline --abbrev-commit打上标签git tag v1.0查看标签git tag针对指定commit id打上标签git tag v0.9 f52c633删除远程分支 git push origin --delete 远程分支名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将推送的远程库名字改成不同的，就可以将一个本地库推送到多个平台</p><pre class="line-numbers language-none"><code class="language-none">git remote add github git@github.com:Sheep1433&#x2F;learngit.gitgit remote add gitee git@github.com:Sheep1433&#x2F;learngit.git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>删除github上的文件夹，在本地仓库使用git rm -r –cached 文件夹名，再使用git commit和git push</p><p>下载源码时切换版本git clone 源码， git tag 列出所有版本，git checkout 版本号</p><p>参与到别人的开源项目中</p><p>在github中fork项目，然后git clone自己的仓库，这样才能提交推送，如果想让官方接受修改，在github上pr(pull requests)</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker入门</title>
      <link href="/2022/11/26/docker-ru-men/"/>
      <url>/2022/11/26/docker-ru-men/</url>
      
        <content type="html"><![CDATA[<h2 id="docker概念"><a href="#docker概念" class="headerlink" title="docker概念"></a>docker概念</h2><p><img src="D:\Sheep1433.github.io\source\picture\image-20230117222926334.png" alt="image-20230117222926334"></p><p><img src="D:\Sheep1433.github.io\source\picture\image-20230117223015800.png" alt="image-20230117223015800"></p><p>核心概念：镜像、容器、仓库</p><h2 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h2><p>不支持windows10家庭版</p><p>CentOS 安装配置</p><p>yum install -y yum-utils device-mapper-persistent-data lvm2安装依赖</p><p> yum-config-manager –add-repo <a href="http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</a>添加源</p><p>yum -y install docker-ce 安装docker</p><p>或者curl -fsSL <a href="https://get.docker.com/">https://get.docker.com</a> | bash -s docker –mirror Aliyun</p><p>此时直接使用docker ps查看进程是无效的，需要先systemctl start docker启动</p><p>设置开机自启动：systemctl enable docker</p><p>docker-compose安装</p><pre class="line-numbers language-none"><code class="language-none"># curl -L https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;1.8.1&#x2F;docker-compose-&#96;uname -s&#96;-&#96;uname -m&#96; &gt; &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose# chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="docker常用命令"><a href="#docker常用命令" class="headerlink" title="docker常用命令"></a>docker常用命令</h2><p><strong>一张图总结 Docker 的命令</strong></p><p><img src="D:\Sheep1433.github.io\source\picture\cmd_logic.5970ea4d.png" alt="img"></p><pre class="line-numbers language-none"><code class="language-none">execbuildcommitexeclogsps pullpushrestartrmrmirunsearchstarttagversioninfosavehistory……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker versiondocker版本信息docker infodocker系统信息# 镜像相关docker images查看所有镜像docker search busybox 在网上搜索镜像docker pull busybOx:latest拉取下载docker save busybox &gt; busybox.tar导出docker load &lt; busybox.tar导入docker rmi busybox:latest删除镜像docker tag busybox:latest busybox:test 更改镜像名docker history busybox 查看镜像创建历史# 容器相关 # docker run中-p：端口映射，--name：命名，-v：挂载目录docker run -d -it busybox &#x2F;bin&#x2F;bash# 这种运行方式，容器不会立刻被退出 -d以守护态运行docker run -d --name&#x3D;busybox busybox:latest ping 114.114.114.114运行容器docker ps, docker ps -a查看运行的容器docker top busybox 查看容器中运行的进程docker stats busybox 查看资源占用# 处于终止状态的容器，可以通过 &#96;docker start&#96; 命令来重新启动。# 此外，&#96;docker restart&#96; 命令会将一个运行态的容器终止，然后再重新启动它。docker start&#x2F;restart&#x2F;stop&#x2F;kill busybox 容器docker pause&#x2F;unpause busybox 暂停容器docker rm -f busybox 强制删除容器docker exec -it busybox ls执行命令docker exec -it elasticsearch &#x2F;bin&#x2F;bash在该容器下执行bash命令docker cp busyboxL&#x2F;etc&#x2F;hosts hosts复制文件docker logs -f busybox查看容器日志docker inspect busybox查看容器&#x2F;镜像的元信息docker inspect -f&#39;&#123;&#123;.Id&#125;&#125;&#39; busybox格式化输出docker build -t &#123;tag&#125; .基于dockerfile在构建镜像docker commit -m &quot;提交信息&quot; &#123;容器id&#125; &#123;命名&#125;将容器转化为镜像<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><p>Nginx容器</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -d --name nginx -p <span class="token number">8088</span>:80 nginx1.17.9<span class="token comment"># 运行</span><span class="token function">docker</span> run -d --name nginx1 -p <span class="token number">8089</span>:80 -v <span class="token variable">$&#123;<span class="token environment constant">PWD</span>&#125;</span>/html:/usr/share/nginx/html/nginx:1.17.9挂载目录<span class="token function">docker</span> stop 停止<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Jenkins容器</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -p <span class="token number">8888</span>:8080 --name myjenkins --user root myjenkins -v /data/jenkins_home:/var/jenkins_home jenkins/jenkins:lts<span class="token function">docker</span> <span class="token builtin class-name">exec</span> -it --user root <span class="token operator">&lt;</span>container id<span class="token operator">></span> /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p><strong>示例</strong></p><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile"># DockerfileFROM        ubuntu:14.04RUN         apt-get updateRUN         apt-get -y install redis-serverEXPOSE      6379ENTRYPOINT  [&quot;&#x2F;usr&#x2F;bin&#x2F;redis-server&quot;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><p>格式为 <code>RUN &lt;command&gt;</code> 或 <code>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code>。</p><p>前者将在 shell 终端中运行命令，即 <code>/bin/sh -c</code>；后者则使用 <code>exec</code> 执行。指定使用其它终端可以通过第二种方式实现，例如 <code>RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]</code>。</p><p>每条 <code>RUN</code> 指令将在当前镜像基础上执行指定命令，并提交为新的镜像。当命令较长时可以使用 <code>\</code> 来换行</p><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>支持三种格式</p><ul><li><code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code> 使用 <code>exec</code> 执行，推荐方式；</li><li><code>CMD command param1 param2</code> 在 <code>/bin/sh</code> 中执行，提供给需要交互的应用；</li><li><code>CMD [&quot;param1&quot;,&quot;param2&quot;]</code> 提供给 <code>ENTRYPOINT</code> 的默认参数；</li></ul><p>指定启动容器时执行的命令，每个 Dockerfile 只能有一条 <code>CMD</code> 命令。如果指定了多条命令，只有最后一条会被执行。</p><p>如果用户启动容器时候指定了运行的命令，则会覆盖掉 <code>CMD</code> 指定的命令。</p><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p>格式为 <code>ENV &lt;key&gt; &lt;value&gt;</code>。 指定一个环境变量，会被后续 <code>RUN</code> 指令使用，并在容器运行时保持。</p><p>例如</p><pre class="line-numbers language-none"><code class="language-none">ENV PG_MAJOR 9.3ENV PG_VERSION 9.3.4RUN curl -SL http:&#x2F;&#x2F;example.com&#x2F;postgres-$PG_VERSION.tar.xz | tar -xJC &#x2F;usr&#x2F;src&#x2F;postgress &amp;&amp; …ENV PATH &#x2F;usr&#x2F;local&#x2F;postgres-$PG_MAJOR&#x2F;bin:$PATH<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p>格式为 <code>EXPOSE &lt;port&gt; [&lt;port&gt;...]</code>。</p><p>告诉 Docker 服务端容器暴露的端口号，供互联系统使用。在启动容器时需要通过 -P，Docker 主机会自动分配一个端口转发到指定的端口。</p><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p>格式为 <code>ADD &lt;src&gt; &lt;dest&gt;</code>。</p><p>该命令将复制指定的 <code>&lt;src&gt;</code> 到容器中的 <code>&lt;dest&gt;</code>。 其中 <code>&lt;src&gt;</code> 可以是Dockerfile所在目录的一个相对路径；也可以是一个 URL；还可以是一个 tar 文件（自动解压为目录）。</p><h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><p>格式为 <code>COPY &lt;src&gt; &lt;dest&gt;</code>。</p><p>复制本地主机的 <code>&lt;src&gt;</code>（为 Dockerfile 所在目录的相对路径）到容器中的 <code>&lt;dest&gt;</code>。</p><p>当使用本地目录为源目录时，推荐使用 <code>COPY</code>。</p><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><p>格式为 <code>WORKDIR /path/to/workdir</code>。</p><p>为后续的 <code>RUN</code>、<code>CMD</code>、<code>ENTRYPOINT</code> 指令配置工作目录。</p><p>可以使用多个 <code>WORKDIR</code> 指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径</p><h2 id="docker-compose常用命令"><a href="#docker-compose常用命令" class="headerlink" title="docker-compose常用命令"></a>docker-compose常用命令</h2><p>Dockerfile 可以让用户管理一个单独的应用容器；而 Compose 则允许用户在一个模板（YAML 格式）中定义一组相关联的应用容器（被称为一个 <code>project</code>，即项目），例如一个 Web 服务容器再加上后端的数据库服务容器等。</p><p>常用命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">build<span class="token comment"># 构建或重新构建服务。服务一旦构建后，将会带上一个标记名，例如 web_db。可以随时在项目目录下运行 `docker-compose build` 来重新构建服务。</span><span class="token builtin class-name">help</span><span class="token function">kill</span><span class="token comment"># 通过发送 `SIGKILL` 信号来强制停止服务容器。支持通过参数来指定发送的信号，例如</span>logsport<span class="token function">ps</span>pull<span class="token function">rm</span>runstartstopup<span class="token comment">#构建，（重新）创建，启动，链接一个服务相关的容器。链接的服务都将会启动，除非他们已经运行。默认情况， `docker-compose up` 将会整合所有容器的输出，并且退出时，所有容器将会停止。如果使用 `docker-compose up -d` ，将会在后台启动并运行所有的容器。默认情况，如果该服务的容器已经存在，`docker-compose up` 将会停止并尝试重新创建他们（保持使用`volumes-from` 挂载的卷），以保证 `docker-compose.yml` 的修改生效。如果你不想容器被停止重新创建，可以使用 `docker-compose up --no-recreate`。如果需要的话，这样将会启动已经停止的容器</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="docker-compose-yml常用字段"><a href="#docker-compose-yml常用字段" class="headerlink" title="docker-compose.yml常用字段"></a>docker-compose.yml常用字段</h2><p>默认的模板文件是 <code>docker-compose.yml</code>，其中定义的每个服务都必须通过 <code>image</code> 指令指定镜像或 <code>build</code> 指令（需要 Dockerfile）来自动构建。</p><p>其它大部分指令都跟 <code>docker run</code> 中的类似。</p><p>如果使用 <code>build</code> 指令，在 <code>Dockerfile</code> 中设置的选项(例如：<code>CMD</code>, <code>EXPOSE</code>, <code>VOLUME</code>, <code>ENV</code> 等) 将会自动被获取，无需在 <code>docker-compose.yml</code> 中再次设置。</p><h3 id="image"><a href="#image" class="headerlink" title="image"></a>image</h3><p>指定为镜像名称或镜像 ID。如果镜像在本地不存在，<code>Compose</code> 将会尝试拉去这个镜像。</p><p>例如：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">image: ubuntuimage: orchardup&#x2F;postgresqlimage: a4bc65fd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="build"><a href="#build" class="headerlink" title="build"></a>build</h3><p>指定 <code>Dockerfile</code> 所在文件夹的路径。 <code>Compose</code> 将会利用它自动构建这个镜像，然后使用这个镜像。</p><pre class="line-numbers language-none"><code class="language-none">build: &#x2F;path&#x2F;to&#x2F;build&#x2F;dir<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="command"><a href="#command" class="headerlink" title="command"></a>command</h3><p>覆盖容器启动后默认执行的命令。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">command: bundle exec thin -p 3000<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="link"><a href="#link" class="headerlink" title="link"></a>link</h3><p>链接到其它服务中的容器。使用服务名称（同时作为别名）或服务名称：服务别名 <code>（SERVICE:ALIAS）</code> 格式都可以。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">links: - db - db:database - redis<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>使用的别名将会自动在服务容器中的 <code>/etc/hosts</code> 里创建。例如：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">172.17.2.186  db172.17.2.186  database172.17.2.187  redis<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>相应的环境变量也将被创建。</p><h3 id="external-links"><a href="#external-links" class="headerlink" title="external_links"></a>external_links</h3><p>链接到 docker-compose.yml 外部的容器，甚至 并非 <code>Compose</code> 管理的容器。参数格式跟 <code>links</code> 类似。</p><pre class="line-numbers language-none"><code class="language-none">external_links: - redis_1 - project_db_1:mysql - project_db_1:postgresql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ports"><a href="#ports" class="headerlink" title="ports"></a>ports</h3><p>暴露端口信息。</p><p>使用宿主：容器 <code>（HOST:CONTAINER）</code>格式或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。</p><pre class="line-numbers language-none"><code class="language-none">ports: - &quot;3000&quot; - &quot;8000:8000&quot; - &quot;49100:22&quot; - &quot;127.0.0.1:8001:8001&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>注：当使用 <code>HOST:CONTAINER</code> 格式来映射端口时，如果你使用的容器端口小于 60 你可能会得到错误得结果，因为 <code>YAML</code> 将会解析 <code>xx:yy</code> 这种数字格式为 60 进制。所以建议采用字符串格式。</em></p><h3 id="expose"><a href="#expose" class="headerlink" title="expose"></a>expose</h3><p>暴露端口，但不映射到宿主机，只被连接的服务访问。</p><p>仅可以指定内部端口为参数</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">expose: - &quot;3000&quot; - &quot;8000&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a>volumes</h3><p>卷挂载路径设置。可以设置宿主机路径 （<code>HOST:CONTAINER</code>） 或加上访问模式 （<code>HOST:CONTAINER:ro</code>）。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">volumes: - &#x2F;var&#x2F;lib&#x2F;mysql - cache&#x2F;:&#x2F;tmp&#x2F;cache - ~&#x2F;configs:&#x2F;etc&#x2F;configs&#x2F;:ro<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="volumes-from"><a href="#volumes-from" class="headerlink" title="volumes_from"></a>volumes_from</h3><p>从另一个服务或容器挂载它的所有卷。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">volumes_from: - service_name - container_name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h3><p>设置环境变量。你可以使用数组或字典两种格式。</p><p>只给定名称的变量会自动获取它在 Compose 主机上的值，可以用来防止泄露不必要的数据。</p><pre class="line-numbers language-none"><code class="language-none">environment:  RACK_ENV: development  SESSION_SECRET:environment:  - RACK_ENV&#x3D;development  - SESSION_SECRET<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="env-file"><a href="#env-file" class="headerlink" title="env_file"></a>env_file</h3><p>从文件中获取环境变量，可以为单独的文件路径或列表。</p><p>如果通过 <code>docker-compose -f FILE</code> 指定了模板文件，则 <code>env_file</code> 中路径会基于模板文件路径。</p><p>如果有变量名称与 <code>environment</code> 指令冲突，则以后者为准。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">env_file: .envenv_file:  - .&#x2F;common.env  - .&#x2F;apps&#x2F;web.env  - &#x2F;opt&#x2F;secrets.env<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>环境变量文件中每一行必须符合格式，支持 <code>#</code> 开头的注释行。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># common.env: Set Rails&#x2F;Rack environmentRACK_ENV&#x3D;development<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h3><p>基于已有的服务进行扩展。例如我们已经有了一个 webapp 服务，模板文件为 <code>common.yml</code>。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># common.ymlwebapp:  build: .&#x2F;webapp  environment:    - DEBUG&#x3D;false    - SEND_EMAILS&#x3D;false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编写一个新的 <code>development.yml</code> 文件，使用 <code>common.yml</code> 中的 webapp 服务进行扩展。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># development.ymlweb:  extends:    file: common.yml    service: webapp  ports:    - &quot;8000:8000&quot;  links:    - db  environment:    - DEBUG&#x3D;truedb:  image: postgres<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>后者会自动继承 common.yml 中的 webapp 服务及相关环节变量。</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell入门</title>
      <link href="/2022/11/26/shell-ru-men/"/>
      <url>/2022/11/26/shell-ru-men/</url>
      
        <content type="html"><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>在 shell 脚本，<code>#!</code> 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 解释器</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行shell脚本的方式：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">sh</span> /path/to/script.sh<span class="token function">bash</span> /path/to/script.sh<span class="token builtin class-name">source</span> /path/to/script.sh./path/to/script.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>#！</code>标识后，如果文件具有可执行权限，可以直接通过<code>path/to/test.sh</code>执行</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token builtin class-name">echo</span> -e <span class="token string">"YES<span class="token entity" title="\c">\c</span>"</span> <span class="token comment"># -e 开启转义 \c 不换行</span><span class="token builtin class-name">echo</span> <span class="token string">"NO"</span><span class="token comment">#  Output:</span><span class="token comment">#  YESNO</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token builtin class-name">printf</span> <span class="token string">"%s %s %s<span class="token entity" title="\n">\n</span>"</span> a b c d e f g h i j<span class="token comment">#  Output:</span><span class="token comment">#  a b c</span><span class="token comment">#  d e f</span><span class="token comment">#  g h i</span><span class="token comment">#  j</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>shell 字符串可以用单引号 <code>&#39;&#39;</code>，也可以用双引号 <code>“”</code>，也可以不用引号。</p><ul><li>单引号的特点<ul><li>单引号里不识别变量</li><li>单引号里不能出现单独的单引号（使用转义符也不行），但可成对出现，作为字符串拼接使用。</li></ul></li><li>双引号的特点<ul><li>双引号里识别变量</li><li>双引号里可以出现转义字符</li></ul></li></ul><h3 id="单引号和双引号"><a href="#单引号和双引号" class="headerlink" title="单引号和双引号"></a>单引号和双引号</h3><p>当局部变量和环境变量包含空格时，它们在引号中的扩展要格外注意。随便举个例子，假如我们用<code>echo</code>来输出用户的输入：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token assign-left variable">INPUT</span><span class="token operator">=</span><span class="token string">"A string  with   strange    whitespace."</span><span class="token builtin class-name">echo</span> <span class="token variable">$INPUT</span>   <span class="token comment">### A string with strange whitespace.</span><span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$INPUT</span>"</span> <span class="token comment">### A string  with   strange    whitespace.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>调用第一个<code>echo</code>时给了它 5 个单独的参数 —— <code>$INPUT</code> 被分成了单独的词，<code>echo</code>在每个词之间打印了一个空格。第二种情况，调用<code>echo</code>时只给了它一个参数（整个$INPUT 的值，包括其中的空格）。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 使用单引号拼接</span><span class="token assign-left variable">name1</span><span class="token operator">=</span><span class="token string">'white'</span><span class="token assign-left variable">str1</span><span class="token operator">=</span><span class="token string">'hello, '</span><span class="token variable">$&#123;name1&#125;</span><span class="token string">''</span><span class="token assign-left variable">str2</span><span class="token operator">=</span><span class="token string">'hello, $&#123;name1&#125;'</span><span class="token builtin class-name">echo</span> <span class="token variable">$&#123;str1&#125;</span>_<span class="token variable">$&#123;str2&#125;</span><span class="token comment"># Output:</span><span class="token comment"># hello, white_hello, $&#123;name1&#125;</span><span class="token comment"># 使用双引号拼接</span><span class="token assign-left variable">name2</span><span class="token operator">=</span><span class="token string">"black"</span><span class="token assign-left variable">str3</span><span class="token operator">=</span><span class="token string">"hello, "</span><span class="token variable">$&#123;name2&#125;</span><span class="token string">""</span><span class="token assign-left variable">str4</span><span class="token operator">=</span><span class="token string">"hello, <span class="token variable">$&#123;name2&#125;</span>"</span><span class="token builtin class-name">echo</span> <span class="token variable">$&#123;str3&#125;</span>_<span class="token variable">$&#123;str4&#125;</span><span class="token comment"># Output:</span><span class="token comment"># hello, black_hello, black</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="字符串常见操作"><a href="#字符串常见操作" class="headerlink" title="字符串常见操作"></a>字符串常见操作</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 获取字符串长度</span><span class="token assign-left variable">text</span><span class="token operator">=</span><span class="token string">"12345"</span><span class="token builtin class-name">echo</span> <span class="token variable">$&#123;<span class="token operator">#</span>text&#125;</span><span class="token comment"># Output:</span><span class="token comment"># 5</span><span class="token comment"># 截取子字符串</span><span class="token assign-left variable">text</span><span class="token operator">=</span><span class="token string">"12345"</span><span class="token builtin class-name">echo</span> <span class="token variable">$&#123;text<span class="token operator">:</span>2<span class="token operator">:</span>2&#125;</span><span class="token comment"># Output:</span><span class="token comment"># 34</span><span class="token comment"># 查找子字符串</span><span class="token assign-left variable">text</span><span class="token operator">=</span><span class="token string">"hello"</span><span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> index <span class="token string">"<span class="token variable">$&#123;text&#125;</span>"</span> ll<span class="token variable">`</span></span><span class="token comment"># Execute: ./str-demo5.sh</span><span class="token comment"># Output:</span><span class="token comment"># 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map创建方式</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 方式一</span><span class="token builtin class-name">declare</span> -A myMapmyMap<span class="token punctuation">[</span><span class="token string">"my03"</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"03"</span><span class="token comment"># 方式二</span><span class="token builtin class-name">declare</span> -A <span class="token assign-left variable">myMap</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"my01"</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"01"</span> <span class="token punctuation">[</span><span class="token string">"my02"</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"02"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>bash只支持一维数组</p><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 创建数组的不同方式</span><span class="token assign-left variable">nums</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">2</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token assign-left variable">colors</span><span class="token operator">=</span><span class="token punctuation">(</span>red yellow <span class="token string">"dark blue"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="输出数组所有元素"><a href="#输出数组所有元素" class="headerlink" title="输出数组所有元素"></a>输出数组所有元素</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token builtin class-name">echo</span> <span class="token variable">$&#123;colors<span class="token punctuation">[</span>*<span class="token punctuation">]</span>&#125;</span><span class="token comment"># Output: red yellow dark blue</span><span class="token builtin class-name">echo</span> <span class="token variable">$&#123;colors<span class="token punctuation">[</span>@<span class="token punctuation">]</span>&#125;</span><span class="token comment"># Output: red yellow dark blue</span><span class="token builtin class-name">printf</span> <span class="token string">"+ %s<span class="token entity" title="\n">\n</span>"</span> <span class="token variable">$&#123;colors<span class="token punctuation">[</span>*<span class="token punctuation">]</span>&#125;</span><span class="token comment"># Output:</span><span class="token comment"># + red</span><span class="token comment"># + yellow</span><span class="token comment"># + dark</span><span class="token comment"># + blue</span><span class="token builtin class-name">printf</span> <span class="token string">"+ %s<span class="token entity" title="\n">\n</span>"</span> <span class="token string">"<span class="token variable">$&#123;colors<span class="token punctuation">[</span>*<span class="token punctuation">]</span>&#125;</span>"</span><span class="token comment"># Output:</span><span class="token comment"># + red yellow dark blue</span><span class="token builtin class-name">printf</span> <span class="token string">"+ %s<span class="token entity" title="\n">\n</span>"</span> <span class="token string">"<span class="token variable">$&#123;colors<span class="token punctuation">[</span>@<span class="token punctuation">]</span>&#125;</span>"</span><span class="token comment"># Output:</span><span class="token comment"># + red</span><span class="token comment"># + yellow</span><span class="token comment"># + dark blue</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数组常见操作"><a href="#数组常见操作" class="headerlink" title="数组常见操作"></a>数组常见操作</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 访问数组部分元素</span><span class="token builtin class-name">echo</span> <span class="token variable">$&#123;nums<span class="token punctuation">[</span>@<span class="token punctuation">]</span><span class="token operator">:</span>0<span class="token operator">:</span>2&#125;</span><span class="token comment"># 访问数组长度</span><span class="token builtin class-name">echo</span> <span class="token variable">$&#123;<span class="token operator">#</span>nums<span class="token punctuation">[</span>*<span class="token punctuation">]</span>&#125;</span><span class="token comment"># Output:</span><span class="token comment"># 3</span><span class="token comment"># 向数组中添加元素</span><span class="token assign-left variable">colors</span><span class="token operator">=</span><span class="token punctuation">(</span>white <span class="token string">"<span class="token variable">$&#123;colors<span class="token punctuation">[</span>@<span class="token punctuation">]</span>&#125;</span>"</span> green black<span class="token punctuation">)</span><span class="token builtin class-name">echo</span> <span class="token variable">$&#123;colors<span class="token punctuation">[</span>@<span class="token punctuation">]</span>&#125;</span><span class="token comment"># Output:</span><span class="token comment"># white red yellow dark blue green black</span><span class="token comment"># 删除元素</span><span class="token builtin class-name">unset</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token builtin class-name">echo</span> <span class="token variable">$&#123;nums<span class="token punctuation">[</span>@<span class="token punctuation">]</span>&#125;</span><span class="token comment"># Output:</span><span class="token comment"># 1 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</p><table><thead><tr><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td><code>-eq</code></td><td>检测两个数是否相等，相等返回 true。</td><td><code>[ $a -eq $b ]</code>返回 false。</td></tr><tr><td><code>-ne</code></td><td>检测两个数是否相等，不相等返回 true。</td><td><code>[ $a -ne $b ]</code> 返回 true。</td></tr><tr><td><code>-gt</code></td><td>检测左边的数是否大于右边的，如果是，则返回 true。</td><td><code>[ $a -gt $b ]</code> 返回 false。</td></tr><tr><td><code>-lt</code></td><td>检测左边的数是否小于右边的，如果是，则返回 true。</td><td><code>[ $a -lt $b ]</code> 返回 true。</td></tr><tr><td><code>-ge</code></td><td>检测左边的数是否大于等于右边的，如果是，则返回 true。</td><td><code>[ $a -ge $b ]</code> 返回 false。</td></tr><tr><td><code>-le</code></td><td>检测左边的数是否小于等于右边的，如果是，则返回 true。</td><td><code>[ $a -le $b ]</code>返回 true。</td></tr></tbody></table><h3 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h3><table><thead><tr><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td><code>!</code></td><td>非运算，表达式为 true 则返回 false，否则返回 true。</td><td><code>[ ! false ]</code> 返回 true。</td></tr><tr><td><code>-o</code></td><td>或运算，有一个表达式为 true 则返回 true。</td><td><code>[ $a -lt 20 -o $b -gt 100 ]</code> 返回 true。</td></tr><tr><td><code>-a</code></td><td>与运算，两个表达式都为 true 才返回 true。</td><td><code>[ $a -lt 20 -a $b -gt 100 ]</code> 返回 false。</td></tr></tbody></table><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><table><thead><tr><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td><code>&amp;&amp;</code></td><td>逻辑的 AND</td><td><code>[[ $&#123;x&#125; -lt 100 &amp;&amp; $&#123;y&#125; -gt 100 ]]</code> 返回 false</td></tr></tbody></table><h3 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h3><table><thead><tr><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td><code>=</code></td><td>检测两个字符串是否相等，相等返回 true。</td><td><code>[ $a = $b ]</code> 返回 false。</td></tr><tr><td><code>!=</code></td><td>检测两个字符串是否相等，不相等返回 true。</td><td><code>[ $a != $b ]</code> 返回 true。</td></tr><tr><td><code>-z</code></td><td>检测字符串长度是否为 0，为 0 返回 true。</td><td><code>[ -z $a ]</code> 返回 false。</td></tr><tr><td><code>-n</code></td><td>检测字符串长度是否为 0，不为 0 返回 true。</td><td><code>[ -n $a ]</code> 返回 true。</td></tr><tr><td><code>str</code></td><td>检测字符串是否为空，不为空返回 true。</td><td><code>[ $a ]</code> 返回 true。</td></tr></tbody></table><h3 id="文件测试运算符"><a href="#文件测试运算符" class="headerlink" title="文件测试运算符"></a>文件测试运算符</h3><table><thead><tr><th align="left">操作符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td align="left">-b file</td><td>检测文件是否是块设备文件，如果是，则返回 true。</td><td><code>[ -b $file ]</code> 返回 false。</td></tr><tr><td align="left">-c file</td><td>检测文件是否是字符设备文件，如果是，则返回 true。</td><td><code>[ -c $file ]</code> 返回 false。</td></tr><tr><td align="left">-d file</td><td>检测文件是否是目录，如果是，则返回 true。</td><td><code>[ -d $file ]</code> 返回 false。</td></tr><tr><td align="left">-f file</td><td>检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</td><td><code>[ -f $file ]</code> 返回 true。</td></tr><tr><td align="left">-g file</td><td>检测文件是否设置了 SGID 位，如果是，则返回 true。</td><td><code>[ -g $file ]</code> 返回 false。</td></tr><tr><td align="left">-k file</td><td>检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td><td><code>[ -k $file ]</code>返回 false。</td></tr><tr><td align="left">-p file</td><td>检测文件是否是有名管道，如果是，则返回 true。</td><td><code>[ -p $file ]</code> 返回 false。</td></tr><tr><td align="left">-u file</td><td>检测文件是否设置了 SUID 位，如果是，则返回 true。</td><td><code>[ -u $file ]</code> 返回 false。</td></tr><tr><td align="left">-r file</td><td>检测文件是否可读，如果是，则返回 true。</td><td><code>[ -r $file ]</code> 返回 true。</td></tr><tr><td align="left">-w file</td><td>检测文件是否可写，如果是，则返回 true。</td><td><code>[ -w $file ]</code> 返回 true。</td></tr><tr><td align="left">-x file</td><td>检测文件是否可执行，如果是，则返回 true。</td><td><code>[ -x $file ]</code> 返回 true。</td></tr><tr><td align="left">-s file</td><td>检测文件是否为空（文件大小是否大于 0），不为空返回 true。</td><td><code>[ -s $file ]</code> 返回 true。</td></tr><tr><td align="left">-e file</td><td>检测文件（包括目录）是否存在，如果是，则返回 true。</td><td><code>[ -e $file ]</code> 返回 true。</td></tr></tbody></table><h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><p>[]和[[]]的区别：</p><p>优先考虑使用[[]]，它是内置在shell中的一个命令，支持字符串的模式匹配等，比如[[ hello &#x3D;&#x3D; hell? ]]，结果为真。</p><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>if语句</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token assign-left variable">x</span><span class="token operator">=</span><span class="token number">10</span><span class="token assign-left variable">y</span><span class="token operator">=</span><span class="token number">20</span><span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token variable">$&#123;x&#125;</span> <span class="token operator">></span> <span class="token variable">$&#123;y&#125;</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>   <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$&#123;x&#125;</span> > <span class="token variable">$&#123;y&#125;</span>"</span><span class="token keyword">elif</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token variable">$&#123;x&#125;</span> <span class="token operator">&lt;</span> <span class="token variable">$&#123;y&#125;</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>   <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$&#123;x&#125;</span> &lt; <span class="token variable">$&#123;y&#125;</span>"</span><span class="token keyword">else</span>   <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$&#123;x&#125;</span> = <span class="token variable">$&#123;y&#125;</span>"</span><span class="token keyword">fi</span><span class="token comment"># Output: 10 &lt; 20</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>case语句</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token builtin class-name">exec</span><span class="token keyword">case</span> <span class="token variable">$&#123;oper&#125;</span> <span class="token keyword">in</span>  <span class="token string">"+"</span><span class="token punctuation">)</span>    <span class="token assign-left variable">val</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> $<span class="token punctuation">&#123;</span>x<span class="token punctuation">&#125;</span> + $<span class="token punctuation">&#123;</span>y<span class="token punctuation">&#125;</span><span class="token variable">`</span></span>    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$&#123;x&#125;</span> + <span class="token variable">$&#123;y&#125;</span> = <span class="token variable">$&#123;val&#125;</span>"</span>  <span class="token punctuation">;</span><span class="token punctuation">;</span>  <span class="token string">"-"</span><span class="token punctuation">)</span>    <span class="token assign-left variable">val</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> $<span class="token punctuation">&#123;</span>x<span class="token punctuation">&#125;</span> - $<span class="token punctuation">&#123;</span>y<span class="token punctuation">&#125;</span><span class="token variable">`</span></span>    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$&#123;x&#125;</span> - <span class="token variable">$&#123;y&#125;</span> = <span class="token variable">$&#123;val&#125;</span>"</span>  <span class="token punctuation">;</span><span class="token punctuation">;</span>  <span class="token string">"*"</span><span class="token punctuation">)</span>    <span class="token assign-left variable">val</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> $<span class="token punctuation">&#123;</span>x<span class="token punctuation">&#125;</span> <span class="token punctuation">\</span>* $<span class="token punctuation">&#123;</span>y<span class="token punctuation">&#125;</span><span class="token variable">`</span></span>    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$&#123;x&#125;</span> * <span class="token variable">$&#123;y&#125;</span> = <span class="token variable">$&#123;val&#125;</span>"</span>  <span class="token punctuation">;</span><span class="token punctuation">;</span>  <span class="token string">"/"</span><span class="token punctuation">)</span>    <span class="token assign-left variable">val</span><span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> $<span class="token punctuation">&#123;</span>x<span class="token punctuation">&#125;</span> / $<span class="token punctuation">&#123;</span>y<span class="token punctuation">&#125;</span><span class="token variable">`</span></span>    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$&#123;x&#125;</span> / <span class="token variable">$&#123;y&#125;</span> = <span class="token variable">$&#123;val&#125;</span>"</span>  <span class="token punctuation">;</span><span class="token punctuation">;</span>  *<span class="token punctuation">)</span>    <span class="token builtin class-name">echo</span> <span class="token string">"Unknown oper!"</span>  <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">esac</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>for循环的几种使用方法</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token keyword">for</span> <span class="token for-or-select variable">arg</span> <span class="token keyword">in</span> elem1 elem2 <span class="token punctuation">..</span>. elemN<span class="token keyword">do</span>  <span class="token comment">### 语句</span><span class="token keyword">done</span><span class="token keyword">for</span> <span class="token variable"><span class="token punctuation">((</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">))</span></span><span class="token punctuation">;</span> <span class="token keyword">do</span>  <span class="token builtin class-name">echo</span> <span class="token variable">$i</span><span class="token keyword">done</span><span class="token assign-left variable">DIR</span><span class="token operator">=</span>/home/zp<span class="token keyword">for</span> <span class="token for-or-select variable">FILE</span> <span class="token keyword">in</span> <span class="token variable">$&#123;DIR&#125;</span>/*.sh<span class="token punctuation">;</span> <span class="token keyword">do</span>  <span class="token function">mv</span> <span class="token string">"<span class="token variable">$FILE</span>"</span> <span class="token string">"<span class="token variable">$&#123;DIR&#125;</span>/scripts"</span><span class="token keyword">done</span><span class="token comment"># 将 /home/zp 目录下所有 sh 文件拷贝到 /home/zp/scripts</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token keyword">while</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token variable">$&#123;x&#125;</span> -lt <span class="token number">10</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">do</span>  <span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">$((</span>x <span class="token operator">*</span> x<span class="token variable">))</span></span>  <span class="token assign-left variable">x</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$((</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token variable">))</span></span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="select循环"><a href="#select循环" class="headerlink" title="select循环"></a>select循环</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token keyword">select</span> <span class="token for-or-select variable">answer</span> <span class="token keyword">in</span> elem1 elem2 <span class="token punctuation">..</span>. elemN<span class="token keyword">do</span>  <span class="token comment">### 语句</span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>select</code>会打印<code>elem1..elemN</code>以及它们的序列号到屏幕上，之后会提示用户输入。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token assign-left variable"><span class="token environment constant">PS3</span></span><span class="token operator">=</span><span class="token string">"Choose the package manager: "</span><span class="token keyword">select</span> <span class="token for-or-select variable">ITEM</span> <span class="token keyword">in</span> bower <span class="token function">npm</span> gem pip<span class="token keyword">do</span><span class="token builtin class-name">echo</span> -n <span class="token string">"Enter the package name: "</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">read</span> PACKAGE<span class="token keyword">case</span> <span class="token variable">$&#123;ITEM&#125;</span> <span class="token keyword">in</span>  bower<span class="token punctuation">)</span> bower <span class="token function">install</span> <span class="token variable">$&#123;PACKAGE&#125;</span> <span class="token punctuation">;</span><span class="token punctuation">;</span>  <span class="token function">npm</span><span class="token punctuation">)</span> <span class="token function">npm</span> <span class="token function">install</span> <span class="token variable">$&#123;PACKAGE&#125;</span> <span class="token punctuation">;</span><span class="token punctuation">;</span>  gem<span class="token punctuation">)</span> gem <span class="token function">install</span> <span class="token variable">$&#123;PACKAGE&#125;</span> <span class="token punctuation">;</span><span class="token punctuation">;</span>  pip<span class="token punctuation">)</span> pip <span class="token function">install</span> <span class="token variable">$&#123;PACKAGE&#125;</span> <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">esac</span><span class="token builtin class-name">break</span> <span class="token comment"># 避免无限循环</span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行这个脚本，会得到如下输出：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ ./my_script<span class="token number">1</span><span class="token punctuation">)</span> bower<span class="token number">2</span><span class="token punctuation">)</span> <span class="token function">npm</span><span class="token number">3</span><span class="token punctuation">)</span> gem<span class="token number">4</span><span class="token punctuation">)</span> pipChoose the package manager: <span class="token number">2</span>Enter the package name: gitbook-cli<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function-name function">calc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token assign-left variable"><span class="token environment constant">PS3</span></span><span class="token operator">=</span><span class="token string">"choose the oper: "</span>  <span class="token keyword">select</span> <span class="token for-or-select variable">oper</span> <span class="token keyword">in</span> + - <span class="token punctuation">\</span>* / <span class="token comment"># 生成操作符选择菜单</span>  <span class="token keyword">do</span>  <span class="token builtin class-name">echo</span> -n <span class="token string">"enter first num: "</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">read</span> x <span class="token comment"># 读取输入参数</span>  <span class="token builtin class-name">echo</span> -n <span class="token string">"enter second num: "</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">read</span> y <span class="token comment"># 读取输入参数</span>  <span class="token builtin class-name">exec</span>  <span class="token keyword">case</span> <span class="token variable">$&#123;oper&#125;</span> <span class="token keyword">in</span>    <span class="token string">"+"</span><span class="token punctuation">)</span>      <span class="token builtin class-name">return</span> <span class="token variable"><span class="token variable">$((</span>$&#123;x&#125; <span class="token operator">+</span> $&#123;y&#125;<span class="token variable">))</span></span>    <span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token string">"-"</span><span class="token punctuation">)</span>      <span class="token builtin class-name">return</span> <span class="token variable"><span class="token variable">$((</span>$&#123;x&#125; <span class="token operator">-</span> $&#123;y&#125;<span class="token variable">))</span></span>    <span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token string">"*"</span><span class="token punctuation">)</span>      <span class="token builtin class-name">return</span> <span class="token variable"><span class="token variable">$((</span>$&#123;x&#125; <span class="token operator">*</span> $&#123;y&#125;<span class="token variable">))</span></span>    <span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token string">"/"</span><span class="token punctuation">)</span>      <span class="token builtin class-name">return</span> <span class="token variable"><span class="token variable">$((</span>$&#123;x&#125; <span class="token operator">/</span> $&#123;y&#125;<span class="token variable">))</span></span>    <span class="token punctuation">;</span><span class="token punctuation">;</span>    *<span class="token punctuation">)</span>      <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$&#123;oper&#125;</span> is not support!"</span>      <span class="token builtin class-name">return</span> <span class="token number">0</span>    <span class="token punctuation">;</span><span class="token punctuation">;</span>  <span class="token keyword">esac</span>  <span class="token builtin class-name">break</span>  <span class="token keyword">done</span><span class="token punctuation">&#125;</span>calc<span class="token builtin class-name">echo</span> <span class="token string">"the result is: <span class="token variable">$?</span>"</span> <span class="token comment"># $? 获取 calc 函数返回值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>💡 说明：</p><ol><li>函数定义时，<code>function</code> 关键字可有可无。</li><li>函数返回值 - return 返回函数返回值，返回值类型只能为整数（0-255）。如果不加 return 语句，shell 默认将以最后一条命令的运行结果，作为函数返回值。</li><li>函数返回值在调用该函数后通过 <code>$?</code> 来获得。</li><li>所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至 shell 解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。</li></ol><h3 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h3><p><strong>位置参数</strong>是在调用一个函数并传给它参数时创建的变量。</p><p>位置参数变量表：</p><table><thead><tr><th>变量</th><th>描述</th></tr></thead><tbody><tr><td><code>$0</code></td><td>脚本名称</td></tr><tr><td><code>$1 … $9</code></td><td>第 1 个到第 9 个参数列表</td></tr><tr><td><code>$&#123;10&#125; … $&#123;N&#125;</code></td><td>第 10 个到 N 个参数列表</td></tr><tr><td><code>$*</code> or <code>$@</code></td><td>除了<code>$0</code>外的所有位置参数</td></tr><tr><td><code>$#</code></td><td>不包括<code>$0</code>在内的位置参数的个数</td></tr><tr><td><code>$FUNCNAME</code></td><td>函数名称（仅在函数内部有值）</td></tr></tbody></table><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token shebang important">#!/usr/bin/env bash</span><span class="token assign-left variable">x</span><span class="token operator">=</span><span class="token number">0</span><span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> -n <span class="token variable">$1</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>  <span class="token builtin class-name">echo</span> <span class="token string">"第一个参数为：<span class="token variable">$1</span>"</span>  <span class="token assign-left variable">x</span><span class="token operator">=</span><span class="token variable">$1</span><span class="token keyword">else</span>  <span class="token builtin class-name">echo</span> <span class="token string">"第一个参数为空"</span><span class="token keyword">fi</span><span class="token assign-left variable">y</span><span class="token operator">=</span><span class="token number">0</span><span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> -n <span class="token variable">$2</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>  <span class="token builtin class-name">echo</span> <span class="token string">"第二个参数为：<span class="token variable">$2</span>"</span>  <span class="token assign-left variable">y</span><span class="token operator">=</span><span class="token variable">$2</span><span class="token keyword">else</span>  <span class="token builtin class-name">echo</span> <span class="token string">"第二个参数为空"</span><span class="token keyword">fi</span><span class="token function-name function">paramsFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token builtin class-name">echo</span> <span class="token string">"函数第一个入参：<span class="token variable">$1</span>"</span>  <span class="token builtin class-name">echo</span> <span class="token string">"函数第二个入参：<span class="token variable">$2</span>"</span><span class="token punctuation">&#125;</span>paramsFunction <span class="token variable">$&#123;x&#125;</span> <span class="token variable">$&#123;y&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果：</p><pre class="line-numbers language-none"><code class="language-none">$ .&#x2F;function-demo2.sh第一个参数为空第二个参数为空函数第一个入参：0函数第二个入参：0$ .&#x2F;function-demo2.sh 10 20第一个参数为：10第二个参数为：20函数第一个入参：10函数第二个入参：20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="函数处理参数"><a href="#函数处理参数" class="headerlink" title="函数处理参数"></a>函数处理参数</h3><p>另外，还有几个特殊字符用来处理参数：</p><table><thead><tr><th>参数处理</th><th>说明</th></tr></thead><tbody><tr><td><code>$#</code></td><td>返回参数个数</td></tr><tr><td><code>$*</code></td><td>返回所有参数</td></tr><tr><td>&#96;$</td><td>参数处理</td></tr><tr><td>$!</td><td>后台运行的最后一个进程的 ID 号</td></tr><tr><td><code>$@</code></td><td>返回所有参数</td></tr><tr><td>$-</td><td>返回 Shell 使用的当前选项，与 set 命令功能相同。</td></tr><tr><td>$?</td><td>函数返回值</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>requests源码学习</title>
      <link href="/2022/04/25/requests-yuan-ma-xue-xi/"/>
      <url>/2022/04/25/requests-yuan-ma-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="init-模块"><a href="#init-模块" class="headerlink" title="__init__模块"></a>__init__模块</h1><p>init总体结构只包含check_compatibility和_check_ctyptography两个函数，对版本信息进行校验</p><p>收获：</p><p>在函数内部多次assert，如果没有完全通过，则会抛出AssertError</p><p>对版本信息验证是否在2.0.0~3.0.0之间，可以使用 assert (2,0,0) &lt;&#x3D; (major, minor, patch) &lt; (3,0,0) 或者assert [2,0,0] &lt;&#x3D; (major, minor, patch) &lt; [3,0,0]，归因于python列表(元组)比较大小</p><p>导包过程中 from . import utils中的.表示当前位置</p><h1 id="compat、-internal-utils模块"><a href="#compat、-internal-utils模块" class="headerlink" title="compat、_internal_utils模块"></a>compat、_internal_utils模块</h1><p>负责python2、python3以及简单的编码处理</p><h1 id="certs模块"><a href="#certs模块" class="headerlink" title="certs模块"></a>certs模块</h1><p>CA证书相关</p><h1 id="exceptions模块"><a href="#exceptions模块" class="headerlink" title="exceptions模块"></a>exceptions模块</h1><p>异常处理模块，应用到了super、hasattr、多继承等，还有字典的pop方法，pop方法可以加一个默认返回值kwargs.pop(‘response’, None)，具体工作原理还需要结合调用时学习</p><p>cookies模块</p><p>hooks模块</p><p>packages模块</p><h1 id="status-codes模块"><a href="#status-codes模块" class="headerlink" title="status_codes模块"></a>status_codes模块</h1><p>该模块中有所有的状态信息，但是内部直接通过_init()执行，似乎没有被调用类或变量，还需要models等模块中结合学习</p><h1 id="auth模块"><a href="#auth模块" class="headerlink" title="auth模块"></a>auth模块</h1><p>身份认证相关，在models、adapter、sessions等模块中调用了，学习这几个模块再返回学习</p><h1 id="API模块"><a href="#API模块" class="headerlink" title="API模块"></a>API模块</h1><p>api模块中，包含request、get、option、post等函数，而get等通过调用request实现函数功能，而request调用的是session.request函数，同时使用with sessions.Session() as session:对session进行上下文管理，确保会话及时关闭，避免出现类似内存泄漏的情况</p><h1 id="structures模块"><a href="#structures模块" class="headerlink" title="structures模块"></a>structures模块</h1><p>新建了两种数据结构，CaseInsensitiveDict和LookupDict，其中CaseInsensitiveDict继承于MutableMapping，实现了__setitem__,<strong>getitem</strong>,<strong>delitem</strong>,<strong>iter</strong>,__len__等方法，解决大小写问题，在self._store中存储的键值形式为 “lower_key” : (“real_key”,”value”)，查询时用小写查询，同时能保留原信息，具体实现方法很值得学习</p><h1 id="session模块"><a href="#session模块" class="headerlink" title="session模块"></a>session模块</h1><ol><li><p>为什么通过requests.Session能访问sessions模块中的Session类，因为在requests库的__init__文件中导入了Session</p><p>实现了跨请求保持cookies方法，具体实现方法还没有看懂，核心在于request方法，首先通过models模块中生成Request类，再执行相应的prepare_request方法，最后执行send方法实现功能，常规通过requests.get方法不能保持cookies可能是因为在get方法中调用的是及时关闭session的请求方法</p><p>session和api中都有request、get等方法，api中的本质上仍然调用的是session的方法</p></li></ol><h1 id="models模块"><a href="#models模块" class="headerlink" title="models模块"></a>models模块</h1><p> models模块中首先创建了RequestEncodingMixin、RequestHooksMixin基类，类中只有相关方法，供后续子类调用，其中RequestHooksMixin类中使用了self.hooks属性，hooks属性由其子类创建，因此此处使用了Mixin模式，并且父类调用了子类的属性。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">RequestHooksMixin</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">register_hook</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> event<span class="token punctuation">,</span> hook<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""Properly register a hook."""</span>        <span class="token keyword">if</span> event <span class="token keyword">not</span> <span class="token keyword">in</span> self<span class="token punctuation">.</span>hooks<span class="token punctuation">:</span>            <span class="token keyword">raise</span> ValueError<span class="token punctuation">(</span><span class="token string">'Unsupported event specified, with event name "%s"'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>hook<span class="token punctuation">,</span> Callable<span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>hooks<span class="token punctuation">[</span>event<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>hook<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此外用到了Callable，这是一种可调用执行对象，并且可以执行参数，也就是在对象后面使用小括号执行代码，那么这个对象就是Callable对象，callable包含函数、类、类里的方法、实现了__callable__方法的实例对象</p><pre class="line-numbers language-python3" data-language="python3"><code class="language-python3">class Stu(object):    def __init__(self, name):        self.name &#x3D; name    def __call__(self, *args, **kwargs):        self.run()    def run(self):        print(&#39;&#123;name&#125; is running&#39;.format(name&#x3D;self.name))stu &#x3D; Stu(&#39;小明&#39;)print(callable(stu))    # Truestu() <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个stu就是实例对象，但是在内部实现了__callable__方法，就可以像函数一样调用</p><p>在该模块中定义了request和response类，并实现了相关方法</p>]]></content>
      
      
      <categories>
          
          <category> requests </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>requests学习</title>
      <link href="/2022/04/17/requests-xue-xi/"/>
      <url>/2022/04/17/requests-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="init-模块"><a href="#init-模块" class="headerlink" title="__init__模块"></a>__init__模块</h1><p>init总体结构只包含check_compatibility和_check_ctyptography两个函数，对版本信息进行校验</p><p>收获：</p><p>在函数内部多次assert，如果没有完全通过，则会抛出AssertError</p><p>对版本信息验证是否在2.0.0~3.0.0之间，可以使用 assert (2,0,0) &lt;&#x3D; (major, minor, patch) &lt; (3,0,0) 或者assert [2,0,0] &lt;&#x3D; (major, minor, patch) &lt; [3,0,0]，归因于python列表(元组)比较大小</p><p>导包过程中 from . import utils中的.表示当前位置</p><h1 id="compat、-internal-utils模块"><a href="#compat、-internal-utils模块" class="headerlink" title="compat、_internal_utils模块"></a>compat、_internal_utils模块</h1><p>负责python2、python3以及简单的编码处理</p><h1 id="certs模块"><a href="#certs模块" class="headerlink" title="certs模块"></a>certs模块</h1><p>CA证书相关</p><h1 id="exceptions模块"><a href="#exceptions模块" class="headerlink" title="exceptions模块"></a>exceptions模块</h1><p>异常处理模块，应用到了super、hasattr、多继承等，还有字典的pop方法，pop方法可以加一个默认返回值kwargs.pop(‘response’, None)，具体工作原理还需要结合调用时学习</p><p>cookies模块</p><p>hooks模块</p><p>packages模块</p><h1 id="status-codes模块"><a href="#status-codes模块" class="headerlink" title="status_codes模块"></a>status_codes模块</h1><p>该模块中有所有的状态信息，但是内部直接通过_init()执行，似乎没有被调用类或变量，还需要models等模块中结合学习</p><h1 id="auth模块"><a href="#auth模块" class="headerlink" title="auth模块"></a>auth模块</h1><p>身份认证相关，在models、adapter、sessions等模块中调用了，学习这几个模块再返回学习</p><h1 id="API模块"><a href="#API模块" class="headerlink" title="API模块"></a>API模块</h1><p>api模块中，包含request、get、option、post等函数，而get等通过调用request实现函数功能，而request调用的是session.request函数，同时使用with sessions.Session() as session:对session进行上下文管理，确保会话及时关闭，避免出现类似内存泄漏的情况</p><h1 id="structures模块"><a href="#structures模块" class="headerlink" title="structures模块"></a>structures模块</h1><p>新建了两种数据结构，CaseInsensitiveDict和LookupDict，其中CaseInsensitiveDict继承于MutableMapping，实现了__setitem__,<strong>getitem</strong>,<strong>delitem</strong>,<strong>iter</strong>,__len__等方法，解决大小写问题，在self._store中存储的键值形式为 “lower_key” : (“real_key”,”value”)，查询时用小写查询，同时能保留原信息，具体实现方法很值得学习</p><h1 id="session模块"><a href="#session模块" class="headerlink" title="session模块"></a>session模块</h1><h1 id="models模块"><a href="#models模块" class="headerlink" title="models模块"></a>models模块</h1><p> models模块中首先创建了RequestEncodingMixin、RequestHooksMixin基类，类中只有相关方法，供后续子类调用，其中RequestHooksMixin类中使用了self.hooks属性，hooks属性由其子类创建，因此此处使用了Mixin模式，并且父类调用了子类的属性。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">RequestHooksMixin</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">register_hook</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> event<span class="token punctuation">,</span> hook<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""Properly register a hook."""</span>        <span class="token keyword">if</span> event <span class="token keyword">not</span> <span class="token keyword">in</span> self<span class="token punctuation">.</span>hooks<span class="token punctuation">:</span>            <span class="token keyword">raise</span> ValueError<span class="token punctuation">(</span><span class="token string">'Unsupported event specified, with event name "%s"'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>hook<span class="token punctuation">,</span> Callable<span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>hooks<span class="token punctuation">[</span>event<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>hook<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此外用到了Callable，这是一种可调用执行对象，并且可以执行参数，也就是在对象后面使用小括号执行代码，那么这个对象就是Callable对象，callable包含函数、类、类里的方法、实现了__callable__方法的实例对象</p><pre class="line-numbers language-python3" data-language="python3"><code class="language-python3">class Stu(object):    def __init__(self, name):        self.name &#x3D; name    def __call__(self, *args, **kwargs):        self.run()    def run(self):        print(&#39;&#123;name&#125; is running&#39;.format(name&#x3D;self.name))stu &#x3D; Stu(&#39;小明&#39;)print(callable(stu))    # Truestu() <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个stu就是实例对象，但是在内部实现了__callable__方法，就可以像函数一样调用</p>]]></content>
      
      
      
        <tags>
            
            <tag> requests </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反转链表</title>
      <link href="/2022/03/12/fan-zhuan-lian-biao/"/>
      <url>/2022/03/12/fan-zhuan-lian-biao/</url>
      
        <content type="html"><![CDATA[<p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"></p><pre class="line-numbers language-none"><code class="language-none">输入：head &#x3D; [1,2,3,4,5]输出：[5,4,3,2,1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># Definition for singly-linked list.</span><span class="token keyword">class</span> <span class="token class-name">ListNode</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>val <span class="token operator">=</span> x        self<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> <span class="token boolean">None</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment"># 双指针迭代法</span>    <span class="token comment"># def reverseList(self, head: ListNode) -> ListNode:</span>    <span class="token comment">#     pre, cur = None, head</span>    <span class="token comment">#     while cur:</span>    <span class="token comment">#         tmp = cur.next</span>    <span class="token comment">#         cur.next = pre</span>    <span class="token comment">#         pre, cur = cur, tmp</span>    <span class="token comment">#     return pre        </span>    <span class="token keyword">def</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> ListNode<span class="token punctuation">:</span>        <span class="token keyword">if</span> head <span class="token keyword">is</span> <span class="token boolean">None</span> <span class="token keyword">or</span> head<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> head        p <span class="token operator">=</span> self<span class="token punctuation">.</span>reverseList<span class="token punctuation">(</span>head<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">)</span>        head<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> head        head<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> <span class="token boolean">None</span>        <span class="token keyword">return</span> p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的前中后序遍历.md</title>
      <link href="/2022/03/10/er-cha-shu-de-qian-zhong-hou-xu-bian-li/"/>
      <url>/2022/03/10/er-cha-shu-de-qian-zhong-hou-xu-bian-li/</url>
      
        <content type="html"><![CDATA[<p>给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>中序</strong> 遍历。</p><pre class="line-numbers language-none"><code class="language-none">输入：root &#x3D; [1,null,2,3]输出：[1,3,2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># Definition for a binary tree node.</span><span class="token keyword">from</span> typing <span class="token keyword">import</span> List<span class="token punctuation">,</span> Optional<span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> left<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> right<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>val <span class="token operator">=</span> val        self<span class="token punctuation">.</span>left <span class="token operator">=</span> left        self<span class="token punctuation">.</span>right <span class="token operator">=</span> right<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token comment"># 递归方法</span>        <span class="token comment"># res = []</span>        <span class="token comment"># def inOrder(node):</span>        <span class="token comment">#     if not node: return </span>        <span class="token comment">#     inOrder(node.left)</span>        <span class="token comment">#     res.append(node.val)</span>        <span class="token comment">#     inOrder(node.right)</span>                <span class="token comment"># if not root: return </span>        <span class="token comment"># inOrder(root)</span>        <span class="token comment"># return res</span>        <span class="token comment"># 迭代方法 颜色标记法</span>        WHITE<span class="token punctuation">,</span> GRAY <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span>WHITE<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> stack<span class="token punctuation">:</span>            color<span class="token punctuation">,</span> node <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> node <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span> <span class="token keyword">continue</span>            <span class="token keyword">if</span> color <span class="token operator">==</span> WHITE<span class="token punctuation">:</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>WHITE<span class="token punctuation">,</span> node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>GRAY<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>WHITE<span class="token punctuation">,</span> node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上方法可以推广至前序和后序，只需要简单更换入栈顺序和递归顺序</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL中limit和offset的用法</title>
      <link href="/2022/03/06/mysql-zhong-limit-he-offset-de-yong-fa/"/>
      <url>/2022/03/06/mysql-zhong-limit-he-offset-de-yong-fa/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-python" data-language="python"><code class="language-python">select<span class="token operator">*</span> <span class="token keyword">from</span> article LIMIT <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span> 等价于 select <span class="token operator">*</span> <span class="token keyword">from</span> article LIMIT <span class="token number">3</span> OFFSET <span class="token number">1</span>取出第<span class="token number">2</span><span class="token operator">-</span><span class="token number">4</span>条数据select<span class="token operator">*</span> <span class="token keyword">from</span> article LIMIT <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span>  等价于 select<span class="token operator">*</span> <span class="token keyword">from</span> article LIMIT <span class="token number">3</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>map函数的使用</title>
      <link href="/2022/03/04/map-han-shu-de-shi-yong/"/>
      <url>/2022/03/04/map-han-shu-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<p><strong>map()</strong> 会根据提供的函数对指定序列做映射。</p><p>map() 函数语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">map</span><span class="token punctuation">(</span>function<span class="token punctuation">,</span> iterable<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>python2.x版本中，返回的是列表</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">map</span><span class="token punctuation">(</span>square<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>python3.x版本中，返回的是迭代器</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">map</span><span class="token punctuation">(</span>square<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token builtin">map</span> <span class="token builtin">object</span> at <span class="token number">0x100d3d550</span><span class="token operator">></span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">map</span><span class="token punctuation">(</span>square<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
